"""Functions for handling multiple promoted items for the same promoter."""
import pandas as pd
from params import PR


def get_rank_util(B, Q, exchange_rate=PR.exchange_rate):
    """Return a representative utility for a single linear ranking of items.
    Args:
        B: float matrix of bids, (items x positions), as generated by `bid.make_bids`
        Q: float matrix of neg user experience, as generated by `comp_bid.make_neg_experience`
        exchange_rate: unit conversion from units of experience in Q to units of USD in B
    Returns:
        float vector in row order of B and Q of utility priority values
    """
    # get a representative position for computing utility ranks
    i = int((B.shape[1] - 1) / 2)
    return B[:, i] + Q[:, i] * exchange_rate


# because of Pandas, this function is pretty slow: about 1.8ms for 1000 items
def get_sameowner_priorities(owner_ids, rank_utils):
    """Return same-owner priorities.
    Args:
        owner_ids: vector of owner_ids
        rank_utils: float vector of ranking score, corresponds with owner_ids
            like computed by get_rank_util
    Returns:
        float vector of same-owner priorities in row order of A, indexed from 0
    """
    # 354us @ 1000 items
    D = pd.DataFrame({
        'owner_ids': owner_ids,
        'rank_utils': rank_utils
    })
    # 1.4ms @ 1000 items
    return D.groupby('owner_ids')['rank_utils'].rank(ascending=False, method='first').to_numpy() - 1


# because of numpy, very fast; 70us for (1000,20)
def same_owner_quality_penalize(Q, priorities,
                                additive=PR.same_promoter_additive,
                                multi=PR.same_promoter_multi):
    """Apply same-promoter quality penalties.
    Penalty is: Q * (multi**priority) + (additive*priority)
    Args:
        Q: float matrix of neg user experience, as generated by `comp_bid.make_neg_experience`
        priorities: float vector of same-owner priority, indexed from 0.
        additive: additive quality penalty
        multi: multiplicative quality penalty
    Returns:
        Q with repeated owner penalties applied
    """
    Q = (Q.T * (multi ** priorities)).T
    Q = (Q.T + (additive * priorities)).T
    return Q


def owner_priority(B, Q, owner_ids, exchange_rate=PR.exchange_rate):
    """Vector of owner priorities. Computed before any allocation adjustments.
    Args:
        B: Bid float matrix
        Q: ENUE float matrix
        owner_ids: vector of owner ids in row order of B and Q
        exchange_rate: float of how to convert Q to units of B
    Returns:
        float vector of whole number owner priorities
    """
    rank_utils = get_rank_util(B, Q, exchange_rate)
    return get_sameowner_priorities(owner_ids, rank_utils)
